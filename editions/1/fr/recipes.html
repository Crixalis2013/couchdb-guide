<title>Recettes</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="performance.html">

<link rel="next" href="unix.html">

<script src="../../../script.js"></script>

<h2 id="recipes">Recettes</h2>

<p>Ce chapitre explore quelques problèmes courants et aborde leur résolution avec CouchDB, le tout en s’appuyant sur les bonnes pratiques et des instructions simples à suivre, pas après pas.

<h3 id="banking">La Banque</h3>

<p>Banquier, c’est un métier sérieux, qui nécessite des bases de données tout aussi sérieuses pour stocker des transactions sérieuses et des informations sérieuses relatives aux comptes. Ils ne peuvent pas laisser l’argent s’évaporer. Jamais. Pas plus qu’ils ne peuvent créer de l’argent. Une banque doit être équilibrée, en tout temps.

<p>La sagesse populaire dit qu’une base de données doit implémenter les <em>transactions</em> pour être prise au sérieux. CouchDB ne supporte pas les transactions dans le sens traditionnel du terme (bien qu’il fonctionne de manière transactionnelle), aussi pourriez-vous conclure que couchDB n’est pas adapté pour stocker des données bancaires. En outre, qui confierait son argent à un canapé ? Eh bien, nous, nous lui ferions confiance. Ce chapitre explique pourquoi.

<h4 id="erasers">Les comptables n’utilisent pas de blanc</h4>

<p>Disons que vous voulez donner 100 € à votre cousin Paul pour la forêt noire qu’il vous a fait parvenir depuis Marseille. Il y a longtemps, vous auriez dû voyager jusqu’à la cité fosséenne pour le payer en main propre ou vous auriez dû lui envoyer la somme par la poste. Ces deux méthodes s’avéraient considérablement pénibles et des alternatives se sont développées. Par exemple, les banques vous proposaient d’acheminer l’argent à Paul pour vous. Bien sûr, ce service engendrait un surcoût, mais vous étiez prêts à le payer pour éviter de voyager. En fait, la banque envoyait quelqu’un porter votre argent à la banque de Paul ; on faisait la même chose que vous auriez faite, mais par l’intermédiare d’un préposé. Les banques pouvaient aussi regrouper les transferts en lots : plutôt que d’envoyer une persone à chaque fois, elle ne faisait plus qu’un voyage. En cas de problème, par exemple si le destinataire avait changé de banque (rappelez-vous qu’il fallait quatre jours aux postes du XVIIIe siècle pour faire Paris-Lyon-Marseille), l’argent était renvoyé au compte du débiteur.

<p>Plus tard, le système bancaire moderne a été introduit et a évité de faire transiter physiquement l’argent sur les routes (au grand dam des bandiers de grand chemin !). Les banques ont l’argent <em>sur le papier</em>, ce qui leur permet de le faire circuler dans envoyer d’objets de valeur. Cependant, le vieux concept est resté dans nos mémoires : pour envoyer de l’argent à quelqu’un, notre banque doit sotir les billets de notre compte et les apporter au compte du créditeur. Aujourd’hui, nous sommes habitués à ce que cela se produise instantanément. Cela ne prend que quelques clis pour commander des biens sur Amazon et qu’ils soient expédiés, alors pourquoi une transaction bancaire prendrait-elle plus de temps ?

<p>Les banques sont toutes électroniques de nos jours (et l’ont été depuis longtemps). Quand nous ordonnons un virement, nous nous attendons à ce qu’il parte immédiatement et nous voulons que cela fonctionne de la même manière qu’antan : prend l’argent de mon compte, dépose-le sur celui de Paul ou, si quelque chose se passe mal, rend-le-moi. Bien que ce soit la démarche logique, ce n’est pas vraiment ce qui se passe derrière le comptoir, et cela ne l’a jamais été depuis que les ordinateurs ont été utilisés par les banques.

<p>Quand vous vous rendez à votre banque et lui demandez d’envoyer de l’argent à Paul, le comptable va <em>amorcer une transaction</em> en prenant note que vous avez demandé d’effectuer un virement. La transaction contiendra la date, la somme et le compte créditeur. Souvenez-vous que les banques doivent toujours être équilibrées : la somme déduite de votre compte ne peut pas se volatiliser. Le comptable va placer votre argent sur un compte <em>de transit</em> que la banque tient pour vous. Le solde de votre compte est alors une agrégation de votre solde courant et des transactions listées dans le compte de transit. Ensuite, la banque vérifie que les coordonnées bancaires de Paul sont correctes et que l’argent peut y être déposé sans problème. Si c’est le cas, l’argent est déplacé dans une autre transaction initiée depuis le compte de transit jusqu’au compte de Paul. Tout est équilibré. Notez qu’il y a plusieurs transactions indépendantes et non une seule qui contiendrait un ensemble d’actions.

<p>Maintenant, considérons un cas d’erreur : le compte de Paul n’existe plus. La banque s’en rend compte lorsqu’elle traite le lot d’opérations qui contient toutes les transactions depuis les comptes de transit. Une deuxième transaction est alors générée, laquelle renvoie l’argent sur votre compte. Notez que la transaction qui a débité initialement votre compte n’est pas <em>défaite</em>, mais que c’est une nouvelle (troisième) transaction qui est créée.

<p>Un autre cas d’erreur : vous n’avez pas assez d’argent sur votre compte pour envoyer 100 € à Paul. Ce sera vérifié par le comptable (ou l’équivalent logiciel) avant que la banque crée la première transaction débitrice. Pour la comptabilité, la banque ne peut pas prétendre qu’il ne s’est rien passé : elle doit garder la trace de l’opération et de son rejet dans un journal. Annuler une opération consiste à effectuer la transaction inverse et jamais en effaçant la première transaction. « Les comptables n’utilisent pas de blanc » est une citation de Pat Helland, un architecte des systèmes transactionnels qui a travaillé pour Microsoft et Amazon.

<p>Pour récapituler, une <em>transaction</em> peut aboutir ou faillir, et rien d’autre. La seule opération que CouchDB garantit comme pouvant aboutir ou faillir est l’écriture d’un document. Toutes les opérations qui sont comprises dans une transaction doivent être contenue dans le même document. Si la logique métier détecte la survenance d’une erreur (par ex., il n’y a pas les fonds requis), une nouvelle transaction inverse doit être créée.

<p>Voyons ce qu’il en est avec CouchDB. Nous avons mentionné que le solde de votre compte est une valeur agrégée. Si nous nous en tenons à cette image, les choses sont simples. Plutôt que mettre à jour le solde des deux comptes (le vôtre et celui de Paul, ou le vôtre et celui de transit), nous créons une seule transaction qui décrit ce que nous sommes en train de faire et recourons à une vue pour obtenir le solde agrégé.

<p>Considérons les transactions suivantes :

<pre>
...
{"from":"Jan","to":"Paul","amount":100}
{"from":"Paul","to":"Steve","amount":20}
{"from":"Work","to":"Jan","amount":200}
...
</pre>

<p>Dans CouchDB, l’écriture d’un document est une opération atomique. Interroger une vue oblige à mettre à jour l’index de la vue en prenant en compte l’ensemble des changements survenus dans tous les documents. La vue résultante est toujours cohérente avec les données présentes dans nos documents. Cela garantie que notre banque est toujours équilibrée. Bien sûr, il existe bien d’autres transactions, mais celles-ci suffiront pour l’exemple.

<p>Comment consultons-nous le solde courant ? C’est simple : une vue <em>MapReduce</em>.

<pre>
function(transaction) {
  emit(transaction.from, transaction.amount * -1);
  emit(transaction.to, transaction.amount);
}
</pre>

<pre>
function(keys, values) {
  return sum(values);
}
</pre>

<p>Ça n’a pas l’air bien compliqué, n’est-ce pas ? Nous stockerons cela dans une vue <code>balance</code> (NdT : solde) dans un document <code>_design/account</code>. Consultons le solde de Jan :

<pre>
curl 'http://127.0.0.1:5984/bank/_design/account/_view/balance?key="Jan"'
</pre>

<p>CouchDB répond :

<pre>
{"rows":[
{"key":null,"value":100}
]}
</pre>

<p>Ça semble correct ! Maintenant, vérifions que notre banque est bien équilibrée. La somme des transactions devrait être égale à zéro :

<pre>
curl http://127.0.0.1:5984/bank/_design/account/_view/balance
</pre>

<p>CouchDB répond :

<pre>
{"rows":[
{"key":null,"value":0}
]}
</pre>

<h4 id="wrap">Résumé</h4>

<p>Cela devrait explique que les applications qui requiernt une forte cohérence peuvent utiliser CouchDB s’il est possible de découper les grosses transactions et petites. Une banque est une bonne approximation d’un métier sérieux, donc vous pouvez être rassurés quant à la possibilité de modéliser votre transactions importantes en petites transactions CouchDB.

<h3 id="ordering">Ordering Lists</h3>

<p>Views let you sort things by any value of your data—even complex JSON keys are possible, as we’ve seen in earlier chapters. Sorting by date is very useful for allowing users to find things quickly; a name is much easier to find in a list of names that is sorted alphabetically. Humans naturally resort to a divide-and-conquer algorithm (sound familiar?) and don’t consider a large part of the input set because they know the name won’t show up there. Likewise, sorting by number and date helps a great deal to let users manage their ever-increasing amounts of data.

<p>There’s another sorting type that is a little more fuzzy. Search engines show you results in order of relevance. That relevance is what the search engine thinks is most relevant to you given your search term (and potential search and surfing history). There are other systems trying to infer from earlier data what is most relevant to you, but they have the near-to-impossible task of guessing what a user is interested in. Computers are notoriously bad at guessing.

<p>The easiest way for a computer to figure out what’s most relevant for a user is to let the user prioritize things. Take a to-do application: it allows users to reorder to-do items so they know what they need to work on next. The underlying problem—keeping a user-defined sorting order—can be found in a number of other places.

<h4 id="integers">A List of Integers</h4>

<p>Let’s stick with the to-do application example. The naïve approach is pretty easy: with each to-do item we store an integer that specifies the location in a list. We use a view to get all to-do items in the right order.

<p>First, we need some example documents:

<pre>
{
  "title":"Remember the Milk",
  "date":"2009-07-22T09:53:37",
  "sort_order":2
}

{
  "title":"Call Fred",
  "date":"2009-07-21T19:41:34",
  "sort_order":3
}

{
  "title":"Gift for Amy",
  "date":"2009-07-19T17:33:29",
  "sort_order":4
}

{
  "title":"Laundry",
  "date":"2009-07-22T14:23:11",
  "sort_order":1
}
</pre>

<p>Next, we create a view with a simple map function that emits rows that are then sorted by the <code>sort_order</code> field of our documents. The view’s result looks like we’d expect:

<pre>
function(todo) {
  if(todo.sort_order &amp;&amp; todo.title) {
    emit(todo.sort_order, todo.title);
  }
}
</pre>

<pre>
{
  "total_rows": 4,
  "offset": 0,
  "rows": [
    {
      "key":1,
      "value":"Laundry",
      "id":"..."
    },
    {
      "key":2,
      "value":"Remember the Milk",
      "id":"..."
    },
    {
      "key":3,
      "value":"Call Fred",
      "id":"..."
    },
    {
      "key":4,
      "value":"Gift for Amy",
      "id":"..."
    }
  ]
}
</pre>

<p>That looks reasonably easy, but can you spot the problem? Here’s a hint: what do you have to do if getting a gift for Amy becomes a higher priority than remembering the milk? Conceptually, the work required is simple:

<ol>

<li>Assign “Gift for Amy” the <code>sort_order</code> of “Remember the Milk.”</li>

<li>Increment the <code>sort_order</code> of “Remember the Milk” and <em>all</em> items that follow by one.</li>

</ol>

<p>Under the hood, this is a lot of work. With CouchDB you’d have to load every document, increment the <code>sort_order</code>, and save it back. If you have a lot of to-do items (I do), then this is some significant work. Maybe there’s a better approach.

<h4 id="floats">A List of Floats</h4>

<p>The fix is simple: instead of using an integer to specify the sort order, we use a float:

<pre>
{
  "title":"Remember the Milk",
  "date":"2009-07-22T09:53:37",
  "sort_order":0.2
}

{
  "title":"Call Fred",
  "date":"2009-07-21T19:41:34",
  "sort_order":0.3
}

{
  "title":"Gift for Amy",
  "date":"2009-07-19T17:33:29",
  "sort_order":0.4
}

{
  "title":"Laundry",
  "date":"2009-07-22T14:23:11",
  "sort_order":0.1
}
</pre>

<p>The view stays the same. Reading this is as easy as the previous approach. Reordering becomes much easier now. The application frontend can keep a copy of the <code>sort_order</code> values around, so when we move an item and store the move, we not only have available the new position, but also the <code>sort_order</code> value for the two new surrounding items.

<p>Let’s move “Gift for Amy” so it’s above “Remember the Milk.” The surrounding <code>sort_order</code>s in the target position are <code>0.1</code> and <code>0.2</code>. To store “Gift for Amy” with the correct <code>sort_order</code>, we simply use the median of the two surrounding values: <code>(0.1 + 0.2) / 2 = 0.3 / 2 = 0.15</code>.

<p>If we query the view again, we now get the desired result:

<pre>
{
  "total_rows": 4,
  "offset": 0,
  "rows": [
    {
      "key":0.1,
      "value":"Laundry",
      "id":"..."
    },
    {
      "key":0.15,
      "value":"Gift for Amy",
      "id":"..."
    },
    {
      "key":0.2,
      "value":"Remember the Milk",
      "id":"..."
    },
    {
      "key":0.3,
      "value":"Call Fred",
      "id":"..."
    }
  ]
}
</pre>

<p>The downside of this approach is that with an increasing number of reorderings, float precision can become an issue as digits “grow” infinitely. One solution is not to care and expect that a single user will not exceed any limits. Alternatively, an administrative task can reset the whole list to single decimals when a user is not active.

<p>The advantage of this approach is that you have to touch only a single document, which is efficient for storing the new ordering of a list and updating the view that maintains the ordered index since only the changed document has to be incorporated into the index.

<h3 id="pagination">Pagination</h3>

<p>This recipe explains how to paginate over view results. Pagination is a user interface (UI) pattern that allows the display of a large number of rows (the <em>result set</em>) without loading all the rows into the UI at once. A fixed-size subset, the <em>page</em>, is displayed along with <em>next</em> and <em>previous</em> links or buttons that can move the <em>viewport</em> over the result set to an adjacent page.

<p>We assume you’re familiar with creating and querying documents and views as well as the multiple view query options.

<h4 id="data">Example Data</h4>

<p>To have some data to work with, we’ll create a list of bands, one document per band:

<pre>
{ "name":"Biffy Clyro" }

{ "name":"Foo Fighters" }

{ "name":"Tool" }

{ "name":"Nirvana" }

{ "name":"Helmet" }

{ "name":"Tenacious D" }

{ "name":"Future of the Left" }

{ "name":"A Perfect Circle" }

{ "name":"Silverchair" }

{ "name":"Queens of the Stone Age" }

{ "name":"Kerub" }
</pre>

<h4 id="view">A View</h4>

<p>We need a simple map function that gives us an alphabetical list of band names. This should be easy, but we’re adding extra smarts to filter out “The” and “A” in front of band names to put them into the right position:

<pre>
function(doc) {
  if(doc.name) {
    var name = doc.name.replace(/^(A|The) /, "");
    emit(name, null);
  }
}
</pre>

<p>The views result is an alphabetical list of band names. Now say we want to display band names five at a time and have a link pointing to the next five names that make up one page, and a link for the previous five, if we’re not on the first page.

<p>We learned how to use the <code>startkey</code>, <code>limit</code>, and <code>skip</code> parameters in earlier chapters. We’ll use these again here. First, let’s have a look at the full result set:

<pre>
{"total_rows":11,"offset":0,"rows":[
  {"id":"a0746072bba60a62b01209f467ca4fe2","key":"Biffy Clyro","value":null},
  {"id":"b47d82284969f10cd1b6ea460ad62d00","key":"Foo Fighters","value":null},
  {"id":"45ccde324611f86ad4932555dea7fce0","key":"Tenacious D","value":null},
  {"id":"d7ab24bb3489a9010c7d1a2087a4a9e4","key":"Future of the Left","value":null},
  {"id":"ad2f85ef87f5a9a65db5b3a75a03cd82","key":"Helmet","value":null},
  {"id":"a2f31cfa68118a6ae9d35444fcb1a3cf","key":"Nirvana","value":null},
  {"id":"67373171d0f626b811bdc34e92e77901","key":"Kerub","value":null},
  {"id":"3e1b84630c384f6aef1a5c50a81e4a34","key":"Perfect Circle","value":null},
  {"id":"84a371a7b8414237fad1b6aaf68cd16a","key":"Queens of the Stone Age","value":null},
  {"id":"dcdaf08242a4be7da1a36e25f4f0b022","key":"Silverchair","value":null},
  {"id":"fd590d4ad53771db47b0406054f02243","key":"Tool","value":null}
]}
</pre>

<h4 id="setup">Setup</h4>

<p>The mechanics of paging are very simple:

<ul>

<li>Display first page.</li>

<li>If there are more rows to show, show <em>next</em> link.</li>

<li>Draw subsequent page</li>

<li>If this is not the first page, show a <em>previous</em> link.</li>

<li>If there are more rows to show, show <em>next</em> link.</li>

</ul>

<p>Or in a pseudo-JavaScript snippet:

<pre>
var result = new Result();
var page = result.getPage();

page.display();

if(result.hasPrev()) {
  page.display_link('prev');
}

if(result.hasNext()) {
  page.display_link('next');
}
</pre>

<h4 id="slow">Slow Paging (Do Not Use)</h4>

<p>Don’t use this method! We just show it because it might seem natural to use, and you need to know why it is a bad idea. To get the first five rows from the view result, you use the <code>?limit=5</code> query parameter:

<pre>
curl -X GET http://127.0.0.1:5984/artists/_design/artists/_view/by-name?limit=5
</pre>

<p>The result:

<pre>
{"total_rows":11,"offset":0,"rows":[
  {"id":"a0746072bba60a62b01209f467ca4fe2","key":"Biffy Clyro","value":null},
  {"id":"b47d82284969f10cd1b6ea460ad62d00","key":"Foo Fighters","value":null},
  {"id":"45ccde324611f86ad4932555dea7fce0","key":"Tenacious D","value":null},
  {"id":"d7ab24bb3489a9010c7d1a2087a4a9e4","key":"Future of the Left","value":null},
  {"id":"ad2f85ef87f5a9a65db5b3a75a03cd82","key":"Helmet","value":null}
]}
</pre>

<p>By comparing the <code>total_rows</code> value to our <code>limit</code> value, we can determine if there are more pages to display. We also know by the <code>offset</code> member that we are on the first page. We can calculate the value for <code>skip=</code> to get the results for the next page:

<pre>
var rows_per_page = 5;
var page = (offset / rows_per_page) + 1; // == 1
var skip = page * rows_per_page; // == 5 for the first page, 10 for the second ...
</pre>

<p>So we query CouchDB with:

<pre>
curl -X GET 'http://127.0.0.1:5984/artists/_design/artists/_view/by-name?limit=5&amp;skip=5'
</pre>

<p>Note we have to use <code>'</code> (single quotes) to escape the <code>&amp;</code> character that is special to the shell we execute <code>curl</code> in.

<p>The result:

<pre>
{"total_rows":11,"offset":5,"rows":[
  {"id":"a2f31cfa68118a6ae9d35444fcb1a3cf","key":"Nirvana","value":null},
  {"id":"67373171d0f626b811bdc34e92e77901","key":"Kerub","value":null},
  {"id":"3e1b84630c384f6aef1a5c50a81e4a34","key":"Perfect Circle","value":null},
  {"id":"84a371a7b8414237fad1b6aaf68cd16a","key":"Queens of the Stone Age","value":null},
  {"id":"dcdaf08242a4be7da1a36e25f4f0b022","key":"Silverchair","value":null}
]}
</pre>

<p>Implementing the <code>hasPrev()</code> and <code>hasNext()</code> method is pretty straightforward:

<pre>
function hasPrev()
{
  return page &gt; 1;
}

function hasNext()
{
  var last_page = Math.floor(total_rows / rows_per_page) +
    (total_rows % rows_per_page);
  return page != last_page;
}
</pre>

<h5 id="dealbreaker">The dealbreaker</h5>

<p>This all looks easy and straightforward, but it has one fatal flaw. Remember how view results are generated from the underlying B-tree index: CouchDB jumps to the first row (or the first row that matches <code>startkey</code>, if provided) and reads one row after the other from the index until there are no more rows (or <code>limit</code> or <code>endkey</code> match, if provided).

<p>The <code>skip</code> argument works like this: in addition to going to the first row and starting to read, <code>skip</code> will skip as many rows as specified, but CouchDB will still read from the first row; it just won’t return any values for the skipped rows. If you specify <code>skip=100</code>, CouchDB will read 100 rows and not create output for them. This doesn’t sound too bad, but it is <em>very</em> bad, when you use <code>1000</code> or even <code>10000</code> as <code>skip</code> values. CouchDB will have to look at a lot of rows unnecessarily.

<p>As a rule of thumb, <code>skip</code> should be used only with single digit values. While it’s possible that there are legitimate use cases where you specify a larger value, they are a good indicator for potential problems with your solution. Finally, for the calculations to work, you need to add a reduce function and make two calls to the view per page to get all the numbering right, and there’s still a potential for error.

<h4 id="fast">Fast Paging (Do Use)</h4>

<p>The correct solution is not much harder. Instead of slicing the result set into equally sized pages, we look at 10 rows at a time and use <code>startkey</code> to jump to the next 10 rows. We even use <code>skip</code>, but only with the value <code>1</code>.

<p>Here is how it works:

<ul>

<li>Request <code>rows_per_page</code> + 1 rows from the view</li>

<li>Display <code>rows_per_page</code> rows, store + 1 row as <code>next_startkey</code> and <code>next_startkey_docid</code></li>

<li>As <em>page information</em>, keep <code>startkey</code> and <code>next_startkey</code></li>

<li>Use the <code>next_*</code> values to create the <em>next</em> link, and use the others to create the <em>previous</em> link</li>

</ul>

<p>The trick to finding the next page is pretty simple. Instead of requesting 10 rows for a page, you request 11 rows, but display only 10 and use the values in the 11th row as the <code>startkey</code> for the next page. Populating the link to the previous page is as simple as carrying the current <code>startkey</code> over to the next page. If there’s no previous <code>startkey</code>, we are on the first page. We stop displaying the link to the next page if we get <code>rows_per_page</code> or less rows back. This is called <em>linked list pagination</em>, as we go from page to page, or list item to list item, instead of jumping directly to a pre-computed page. There is one caveat, though. Can you spot it?

<p>CouchDB view keys do not have to be unique; you can have multiple index entries <em>read</em>. What if you have more index entries for a key than rows that should be on a page? <code>startkey</code> jumps to the first row, and you’d be screwed if CouchDB didn’t have an additional parameter for you to use. All view keys with the same value are internally sorted by <code>docid</code>, that is, the ID of the document that created that view row. You can use the <code>startkey_docid</code> and <code>endkey_docid</code> parameters to get subsets of these rows. For pagination, we still don’t need <code>endkey_docid</code>, but <code>startkey_docid</code> is very handy. In addition to <code>startkey</code> and <code>limit</code>, you also use <code>startkey_docid</code> for pagination if, and only if, the extra row you fetch to find the next page has the same key as the current <code>startkey</code>.

<p>It is important to note that the <code>*_docid</code> parameters only work <em>in addition</em> to the <code>*key</code> parameters and are only useful to further narrow down the result set of a view for a single key. They do not work on their own (the one exception being the built-in _<code>all_docs</code> view that already sorts by document ID).

<p>The advantage of this approach is that all the key operations can be performed on the super-fast B-tree index behind the view. Looking up a page doesn’t include scanning through hundreds and thousands of rows unnecessarily.

<h4 id="jump">Jump to Page</h4>

<p>One drawback of the linked list style pagination is that you can’t pre-compute the rows for a particular page from the page number and the rows per page. Jumping to a specific page doesn’t really work. Our gut reaction, if that concern is raised, is, “Not even Google is doing that!” and we tend to get away with it. Google always pretends on the first page to find 10 more pages of results. Only if you click on the second page (something very few people actually do) might Google display a reduced set of pages. If you page through the results, you get links for the previous and next 10 pages, but no more. Pre-computing the necessary <code>startkey</code> and <code>startkey_docid</code> for 20 pages is a feasible operation and a pragmatic optimization to know the rows for every page in a result set that is potentially tens of thousands of rows long, or more.

<p>If you really do need to jump to a page over the full range of documents (we have seen applications that require that), you can still maintain an integer value index as the view index and take a hybrid approach at solving pagination.
