<title>Consistencia Eventual</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="why.html">

<link rel="next" href="tour.html">

<script src="../../../script.js"></script>

<h2 id="consistency">Consistencia Eventual</h2>

<p>En el capitulo anterior vimos que la flexibilidad de CouchDB nos permite evolucionar nuestra data mientras nuestra aplicacion crece. En este capitulo vamos a explorar como trabajar "con el grano" de CouchDB promueve simplicidad en nuestras aplicaciones y nos ayuda a construir sistemas escalables y distribuidos.

<h3 id="grain">Trabajando con el Corriente</h3>

<p>Un <em>sistema distribuido</em> es un sistema que opera robustamente sobre una red amplia. Una caracteristica particular de redes en computacion es que un enlance en la red puede potencialmente desaparecer, y hay varias estrategias para manejar este tipo de segmentacion.CouchDB se diferencia de otras tecnologias por que acepta consistencia eventual, en constraste a dar prioridad a la consistencia absoluta sobre la disponibildad, como RDBMS or Paxos. Lo que estos sistemas tienen en comun es el entendimiento de que la informacion actua diferentement cuando mucha gente la accede en simulaneo. Su enfoque difiere en que aspecto de <em>consistencia</em>, <em>disponibilidad</em>, o <em>tolerancia en las particiones</em> priorizan.

<p>Diseña sistemas distribuidos es dificil. Muchos de las trampas que vaz a encontrar no son inmediatamente obvias. Nosotros no tenemos todas las soluciones, y CouchDB no es una panacea, pero cuando vaz en el sentido de la corriente con CouchDB en vez de encontra, el camino de menos resistencia te lleva a aplicaciones naturalmente escalables.

<p>Por supuesto, construir un sistema distribuido es solo el principio. Un sitio web con una base de datos que solo esta disponible la mitad del tiempo practicamente no tiene ninguna valor. Desafortunadamente, el enfoque tradicional sobre consistencia de bases de datos relacionales hace muy facil que los programadores dependan en estado global y otros no-nos de alta disponibilidad, sin darse cuenta que lo estan haciendo. Antes de examinar como CouchDB promueve escalabilidad, vamos a investigar las restricciones encontradas por sistemas distribuidos. Despues de ver los problemas que aparece cuando partes de tu aplicacion no pueden confiar en estar en contacto constante con otras partes, veremos que CouchDB provee una manera intuitive y util para modelar aplicaciones de alta disponibilidad.

<h3 id="cap">El Teorema CAP</h3>

<p>El teoream CAP describe diferentes estrategias para distribuir la logica de una aplicacion atravez de reders. La solucion de CouchDB usa replicacion para propagar los cambios de la aplicacion atravez de los nodos participantes. Este es un enfoque fundamentalmente diferente que algoritmos de concenso y base de datos relacionales, los cuales operan en una interseccion diferente de consistencia, disponibilidad y toleracian en las particiones.

<p>El teoream CAP, mostrado en la <a href="#figure/1">Figura 1, “The CAP theorem”</a>, identifica tres  three preocupaciones distintas:

<dl>

<dt>Consistencia</dt>

<dd>Todos los clientes de la base de datos ven la misma informacion, inclusive con modificaciones concurrentes.</dd>

<dt>Disponibilidad</dt>

<dd>Todos los clientes de la base de datos son capazes de acceder alguna version de la informacion.</dd>

<dt>Tolerancia a la Particion</dt>

<dd>La base de datos puede ser divida sobre multiples servidores.</dd>

</dl>

<p>Escoge dos.

<div class="figure" id="figure/1">

<img src="consistency/01.png">

<p class="caption">Figura 1. El teorema CAP

</div>

<p>Cuando un sistema crece suficientemente grande que un solo nodo es incapar de manejar la carga requerida, una solucion razonable es añadir mas servidores. Cuando añadimos nodos tenemos que pensar como particionar la informacion entre ellos. Tenemos varias bases de datos que comparten exactamente la misma informacion? Ponemos diferentes partes de la informacion en diferentes servidores? Solo dejamos que algunos servidores escriban la informacion y otros manejen la lectura?

<p>Sin importar que enfoque tomemos, el problema que seguiremos encontrando es el de mantener todos los servidores de datos sincronizados. Si escribes alguna informacion en un nodo, como vaz a estar a estar seguro que la lectura en otros servidor refleja la nueva informacion? Estos eventos pueden estar separados por milisegundos. Aun con una coleccion modesta de servidores de datos este problema puede volverse extremadamente complejo.

<p>Cuando es absolutamente critico que todos los clientes vean una vista consistente de la base de datos, el usuario de un nodo tendra que espera por que los otros nodos esten en concordancia antes de poder leer o escribir de la base de datos. En este caso vemos que la<em>disponbilidad</em> queda relegada por la <em>consistencia</em>. Sin embargo, hay situaciones donde disponibilidad triunfa sore la consistencia:

<blockquote>

<p>Cada node en el sistem deberia poder hacer decisiones basadas puramente en el estado local. Si tienes que hacer algo bajo alta carga con fallas ocurriendo y tienes que alcanzar concorandia, entonces estas perdido. Si te preocupa la escabilidad, cualquier algoritmo que te fuerza a mantener concordancia sera eventualmente el cuello de botella. Tomalos por sentado.

<p class="attribution">&mdash;Werner Vogels, Amazon CTO y Vice Presidente

</blockquote>

<p>Si disponibilidad es una prioridad, podemos dejar a los clientes escribir la informacion a un node de la base de datos sin esperar que los otros nodos esten en corcodancia. Si la base de datos sabe como reconciliar estas operaciones entre nodos, logramos un tipo de 'consistencia eventual' a cambio de alta disponbilidad. Este es un compromiso sorprendemente aplicable para muchas aplicaciones.

<p>A diferencia de bases de datos relaciones tradicionales, donde cada accion realiza es sujeta a chequeos de consistencia en toda la base de datos, CouchDB hace muy simple construir aplicaciones que sacrifican consistencia inmediate a cambio the enormes mejoras de rendimiento gracias a la distribucion.

<h3 id="local">Consistencia Local</h3>

<p>Antes que intentemos entender como CouchDB opera en un grupo, es importante que entendamos el funcionamiento interno de un solo nodo de CouchDB. El API de CouchDB esta diseñado para proveer una capa delgada alreador del nucleo de la base de datos. Mirando de cerca la estructura del nucleo de la base de datos, tendremos un mejor entendimiento del API que lo rodea.

<h4 id="key">La Llave de tu Informacion</h4>

<p>En el corazon de CouchDB hay un poderoso motor de almacenamiento <em>B-tree</em>. Un B-tree es una estructura de informacion ordenada que permite busquedas, inserciones, y eliminaciones en tiempo logaritmico. Como la <a href="#figure/2">Figura 2, “Anatomia de una solicitud de vista”</a> ilustra, CouchB usa este motor de almacenamiento B-tree para toda la data interna, documentos y vistas. Si entendemos una, entenderemos todos.

<div class="figure" id="figure/2">

<img src="consistency/02.png">

<p class="caption">Figura 2. Anatomia de una solicitud de vista

</div>

<p>CouchDB usa MapReduce para computar los resultados de una vista. MapReduce usa dos funciones, "map" y "reduce", que son aplicadas a cada document aisladamente. Puediendo aislar estas operaciones significa que procesar las vistas se presta a computacion en paralelo e incremental. Aun mas importante, debido a que estas funciones produce pares de llaves/valores, CouchDB es capaz de insertarlas en el almacenamiento de arbol binario, ordenadas por llave. Busquedas por llave o rango de llaves son operaciones extremadamente eficientes usando el arbol binario, descrito en <em>Cota superior asintótica</em> como <em>O(log N)</em> y <em>O(log N + K)</em>, respectivamente.

<<p>En CouchDb, accedemos documentos o resultados de vistas usando llaves o rango de llaves. Esto es una asignacion directa a las operaciones subyacentes realizadas en el motor de almacenamiento de CouchDB. Junto con inserciones y modificaciones de documentos, esta asignacion directa es la razon por lo que describimos el API de CouchDB como una envoltura delgada alrededor de el nucleo de la base de datos.

<p>Porder accedes resultados solo usando llaves es una restriccion importante por que nos permite brindar enormes ganancias en rendimiento. Ademas de las mejoras masivas de velocidad, podemos particionar la informacion sobre multiples nodos, sin afectar nuestra habilidad de consultar cada nodo en aislamiento. <em>BigTable</em>, <em>Hadoop</em>, <em>SimpleDB</em>, y <em>memcached</em> restringen la busquedad de objectos usando llaves por exactamente estas razones.

<h4 id="locking">Sin Bloqueo</h4>

<p>Una table en una base de datos relacional es una sola estructura. Si quieres modificar una tabla — digamos, modificar una fila — el sistema de baso de datos debe asegurar que nadie mas este tratando de modificar esa fila y que nadie pueda leer esa file mientras este siendo modificada. La manera comun de manejar esto usa lo que conocemos como <em>candado</em>. Si multiples clientes quieren acceder una tabla, el primer cliente obtiene el candado, haciendo esperar a los demas. Cuando la solicitud del primer cliente es procesada, el siguiente cliente obtiene el candado y asi sucesivamente. Esta ejecucion serial de solicitudes, aun si llegan el paralelo, desperdicia una cantidad significative de poder de procesamiento del servidor. Bajo alta carga, una base de datos relaciones puede tomar mas tiempo averiguando quien esta permitido de hacer que, y en que orden, que los que toma hacer el trabajo actual.

<p>En vez de candados, CouchDB usa <em>Control de Concurrencia multi-version (MVCC abbreviacion ingles)</em> para manejar el accesso concurrente a la base de datos. La <a href="#figure/3">Figura 3, “MVCC significa no candados</a> ilustra las diferencias entre MVCC y mecanismos de bloqueo tradicionales. MBCC significa que CouchDB puede ejecutar a toda velocidad, todo el tiempo, inclusive bajo alta carga. Las solicitudes son ejecutadas en paralelo, haciendo excelente uso de hasta la ultima gota de poder de procesamiento que el servidor puede ofrecer.

<div class="figure" id="figure/3">

<img src="consistency/03.png">

<p class="caption">Figura 3. MVCC significa no bloqueo

</div>

<p>Los documentos en CouchDB son versionados, tal como serian en un sistema de control de versiones regular com Subversion. Si quieres cambiar un valor en un documento, creas una version enteramente nueva del documento y la grabas sobre la antigua. Despues de hacer esto, terminas con dos versions del mismo document, una antigua y una nueva.

<p>Como ofrece esto mejoras sobre candados? Considera un grupo de solicitudes queriendo acceder un documento. La primera solicitud lee el documento. Mientras este se procesa, una segunda solicitud modifica el documento. Dado que la segunda solicitude incluye una version completamente nueva del documento, CouchDB puede simplemente anadirlo a la base de datos sin tener que esperar que termine la solicitud de lectura.

<p>Cuando una tercera solicitud quiere leer el mismo document, CouchDB apuntara a la nueva version que acaba de ser grabada. Durante todo este proceso, la primera solicitud podria estar aun leyendo la version original.

<p>Una solicitud de lectura siempre obtendra la version {{snapshot}} mas reciente de tu base de datos.

<h4 id="validation">Validacion</h4>

<p>Como desarolladores de aplicaciones, debemos pensar en que tipo de entradas debemos aceptar y que tipos debemos rechazar. El poder expresivo de hacer este tipo de validacion sobre informacion compleja <em>dentro</em> base de datos relacional deja mucho que desear. Por suerte, CouchDB provee una poderosa manera de realizar validaciones por documento desde dentro de la base de datos.

<p>CouchDB puede validar documentos usando funciones de JavaScript similares a las usadas en MapReduce. Cada vez que tratas de modificar un documento, CouchDB pasara a la funcion de validacion una copia del documento existente, una copia del nuevo documento, y una colecion de informacion adicional, como los detalles de autenticacion del usuario. La funcion de validacion tiene ahora la oportunidad de aprovar o negar la modificacion.

<p>Trabajando en direcion a la corriente y dejando a CouchDB hace esto por nosotro, nos ahorramos una cantidad tremenda de ciclos de CPU que serian de lo contrario gastados serializando graficos de objectos de SQL, convirtiendolos en objectos de nuestro dominio, y usando estos objectos para hacer validaciones en la aplicacion.

<h3 id="distributed">Consistencia Distribuida</h3>

<p>Manter la consistencia dentro de un solo nodo de base datos es relativamente facil para la mayoria de las bases de datos. El problema real comienza a aparecer cuando tratas de mantener la consistencia entre multiples servidores de bases de datos. Si un cliente hace una operacion de escritura en el servidor <em>A</em>, como estamos seguros que esto es consistente con el servidor <em>B</em>, o <em>C</em>, o <em>D</em>? Para las bases de datos relaciones esto es un problema muy complejo, con libros enteros dedicados a su solucion. Podria usar {{multi-master}} mutiples maestros, maestro/esclavo, particionamiento, {{sharding}} y toda clases de tecnicas complejas.

<h4 id="incremental">Replicacion Incremental</h4>

<p>Por que las operaciones de CouchDB toman lugar dentro del contexto de un solo documento, si tu quieres usar dos nodos de base de datos, no te tienes que preocupar de que ellos se mantengan en comunicacion constante. CouchDB logra <em>consistencial eventual</em> entre las bases de datos usando replicacion incremental, un proceso en que los cambios en los documentos son periodicamente copiados entre los servidores. Somos capaces de construir lo que se conoce como un grupo de bases de datos que <em>comparten nada</em> donde cada nodo es independiente y auto suficiente, sin dejar ningun punto de disputa a traves del sistema.

<p>Need to scale out your CouchDB database cluster? Just throw in another server.

<p>As illustrated in <a href="#figure/4">Figure 4, “Incremental replication between CouchDB nodes”</a>, with CouchDB’s incremental replication, you can synchronize your data between any two databases however you like and whenever you like. After replication, each database is able to work independently.

<p>You could use this feature to synchronize database servers within a cluster or between data centers using a job scheduler such as <em>cron</em>, or you could use it to synchronize data with your laptop for offline work as you travel. Each database can be used in the usual fashion, and changes between databases can be synchronized later in both directions.

<div class="figure" id="figure/4">

<img src="consistency/04.png">

<p class="caption">Figure 4. Incremental replication between CouchDB nodes

</div>

<p>What happens when you change the same document in two different databases and want to synchronize these with each other? CouchDB’s replication system comes with automatic conflict detection <em>and</em> resolution. When CouchDB detects that a document has been changed in both databases, it flags this document as being in conflict, much like they would be in a regular version control system.

<p>This isn’t as troublesome as it might first sound. When two versions of a document conflict during replication, the <em>winning</em> version is saved as the most recent version in the document’s history. Instead of throwing the <em>losing</em> version away, as you might expect, CouchDB saves this as a previous version in the document’s history, so that you can access it if you need to. This happens automatically and consistently, so both databases will make exactly the same choice.

<p>It is up to you to handle conflicts in a way that makes sense for your application. You can leave the chosen document versions in place, revert to the older version, or try to merge the two versions and save the result.

<h4 id="study">Case Study</h4>

<p>Greg Borenstein, a friend and coworker, built a small library for converting Songbird playlists to JSON objects and decided to store these in CouchDB as part of a backup application. The completed software uses CouchDB’s MVCC and document revisions to ensure that Songbird playlists are backed up robustly between nodes.

<div class="aside note">

<p>Songbird is a free software media player with an integrated web browser, based on the Mozilla XULRunner platform. Songbird is available for Microsoft Windows, Apple Mac OS X, Solaris, and Linux.

</div>

<p>Let’s examine the workflow of the Songbird backup application, first as a user backing up from a single computer, and then using Songbird to synchronize playlists between multiple computers. We’ll see how document revisions turn what could have been a hairy problem into something that <em>just works</em>.

<p>The first time we use this backup application, we feed our playlists to the application and initiate a backup. Each playlist is converted to a JSON object and handed to a CouchDB database. As illustrated in <a href="#figure/5">Figure 5, “Backing up to a single database”</a>, CouchDB hands back the document ID and revision of each playlist as it’s saved to the database.

<div class="figure" id="figure/5">

<img src="consistency/05.png">

<p class="caption">Figure 5. Backing up to a single database

</div>

<p>After a few days, we find that our playlists have been updated and we want to back up our changes. After we have fed our playlists to the backup application, it fetches the latest versions from CouchDB, along with the corresponding document revisions. When the application hands back the new playlist document, CouchDB requires that the document revision is included in the request.

<p>CouchDB then makes sure that the document revision handed to it in the request matches the current revision held in the database. Because CouchDB updates the revision with every modification, if these two are out of synchronization it suggests that someone else has made changes to the document between the time we requested it from the database and the time we sent our updates. Making changes to a document after someone else has modified it without first inspecting those changes is usually a bad idea.

<p>Forcing clients to hand back the correct document revision is the heart of CouchDB’s optimistic concurrency.

<p>We have a laptop we want to keep synchronized with our desktop computer. With all our playlists on our desktop, the first step is to “restore from backup” onto our laptop. This is the first time we’ve done this, so afterward our laptop should hold an exact replica of our desktop playlist collection.

<p>After editing our Argentine Tango playlist on our laptop to add a few new songs we’ve purchased, we want to save our changes. The backup application replaces the playlist document in our laptop CouchDB database and a new document revision is generated. A few days later, we remember our new songs and want to copy the playlist across to our desktop computer. As illustrated in <a href="#figure/6">Figure 6, “Synchronizing between two databases”</a>, the backup application copies the new document and the new revision to the desktop CouchDB database. Both CouchDB databases now have the same document revision.

<div class="figure" id="figure/6">

<img src="consistency/06.png">

<p class="caption">Figure 6. Synchronizing between two databases

</div>

<p>Because CouchDB tracks document revisions, it ensures that updates like these will work only if they are based on current information. If we had made modifications to the playlist backups between synchronization, things wouldn’t go as smoothly.

<p>We back up some changes on our laptop and forget to synchronize. A few days later, we’re editing playlists on our desktop computer, make a backup, and want to synchronize this to our laptop. As illustrated in <a href="#figure/7">Figure 7, “Synchronization conflicts between two databases”</a>, when our backup application tries to replicate between the two databases, CouchDB sees that the changes being sent from our desktop computer are modifications of out-of-date documents and helpfully informs us that there has been a conflict.

<p>Recovering from this error is easy to accomplish from an application perspective. Just download CouchDB’s version of the playlist and provide an opportunity to merge the changes or save local modifications into a new playlist.

<div class="figure" id="figure/7">

<img src="consistency/07.png">

<p class="caption">Figure 7. Synchronization conflicts between two databases

</div>

<h3 id="wrap">Wrapping Up</h3>

<p>CouchDB’s design borrows heavily from web architecture and the lessons learned deploying massively distributed systems on that architecture. By understanding why this architecture works the way it does, and by learning to spot which parts of your application can be easily distributed and which parts cannot, you’ll enhance your ability to design distributed and scalable applications, with CouchDB or without it.

<p>We’ve covered the main issues surrounding CouchDB’s consistency model and hinted at some of the benefits to be had when you work <em>with</em> CouchDB and not against it. But enough theory—let’s get up and running and see what all the fuss is about!
